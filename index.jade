doctype html
html
  head
  title Crypto
  meta(charset="utf-8")
  meta(name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no")
  link(rel="stylesheet" href="static/bootstrap.readable.min.css")
  link(rel="stylesheet" href="static/style.css")
  //- Highlight JS
  link(rel="stylesheet" href="static/hightlight.default.min.css")
  script( src="static/highlight.pack.js")
  script.
    hljs.initHighlightingOnLoad();
  //- jQuery
  script(src="https://ajax.googleapis.com/ajax/libs/jquery/1.12.4/jquery.min.js")
  body
    .container
      .row-xs-10.row-xs-offset-1
        .title
          .flex
            h1 Small Python Cyphers
            h4 by Cole
          a(href="http://github.com/crellison")
            img.git(src="static/Github-black.svg")
        p This site is designed to showcase some simple cypher algorithms that present themselves as basic programming problems. The cryptography exercises here are not meant to be comprehensive, but will hopefully provide an introduction to programming in Python. 
        p Cryptography is commonly taught in early CS courses, as such problems present unique challenges in function architecture. Cyphers are reversible functions which take a message and a key and return a predictable, unique output based on the message. The reversability and uniqueness is key. A cypher without uniqueness is useless, as that would imply that the encryption of "quavering peaches" would be the same as that of "bobbing buoy." If we have uniqueness, but no reversibility, then the algorithm is a hash function, instead of an encryption algorithm, and it is impossible to divine the original message from the encrypted one. The functions on this page are designed to demonstrate these principles and show the variety of basic cyphers and how to crack them. A word of advice though, none of the encryptions on this page are secure (in any form of the word) to someone with access to a computer and some basic algebra skills. 
        p As I find time, I will update this site with more advanced algorithms and cryptography techniques. If you want to learn more about advanced cryptography techniques, I highly recommend 
          a(href="cryptopals.com") Cryptopals
          | .
        .cyphers
          .oneCypher
            h4 The Caesar Cypher
            p This is the classic (and possibly the oldest) cypher using the Roman alphabet. Supposedly used by the Emperor of Rome himself to send messages between generals during battle, this cypher is easy to conceive and implement, though provides virtually no security from hacking. It is implemented by a 'frameshift' transformation of the alphabet by an integer between 0 (the trivial case) and 25. Though not required, my version of this cypher ignores all non-alpha characters, as the romans didn't have punctuation and spacing between words was non-standard.
            p.solution click the box to reveal solution
            pre
              code.python
                | def caesarEncrypt(msg,key):
                |   msg = msg.lower()
                |   #get the character code for a, we will use this as a baseline to select characters
                |   start = ord('a') 
                |   rVal = ''
                |   for ch in msg:
                |     # if character is a letter, use the frameshift, otherwise use the character
                |     rVal += chr(start + (ord(ch) - start + key) % 26) if ch.isalpha() else ''
                |   return rVal
            p The decrypt for the caesar cypher is as simple as it's encryption. All we need to do is change the direction of the frameshift. Pass in the negation key value and you will get your original message! No need for a separate function!
            p Now we will get a little more advanced. Say you find a scrap of paper, or intercept an email, and suspect the contents are encrypted with a caesar cypher. If you want to break this without the key (and without printing out the 26 possible options), it will require some basic frequency analysis. To do this, we will need a large text document. Though many are available online through 
              a(href="gutenburg.org") Project Gutenburg
              | , I (and many programmers) have a soft spot for Lewis Carrol's 
              a(href="txt/alice.txt") Alice in Wonderland
              | , so my implementation will use that. First we need to build a function that reads a .txt file and generate a frequency table for character frequencies. The more advanced version of this table just looks at character pairing frequencies (i.e. the frequency at which 'ae' appears), but I will leave that to you to implement on your free time for fun!
            p.solution click the box to reveal solution
            pre
              code.python
                | # get character frequencies of large text doc (alice.txt)
                | def getFrq(filename):
                |   freq = {}
                |   total = 0
                |   with open(filename) as file:
                |     while True:
                |       c = file.read(1)
                |       if not c: # then we have reached the end of the document
                |         break
                |       total+=1
                |       # if c hasn't appeared yet, instantiate it
                |       freq[c] = 1 if not c in freq.keys() else freq[c]+1
                |   for key in freq.keys():
                |     freq[key]/=total
                |   return freq
            pre
              code.no-highlight
                | For those of you who implemented the character pairing analysis on alice.txt, here are some pairings to test against your output. (Remember that you should ignore non-alpha characters, but still need to test the frequencies of word-end letters to word-start letters.)
                | 
                |   'ae' : 1.625831206204172e-05
                |   'qu' : 0.0017802851707935682
                |   'po' : 0.001845318419041735
                |   'rs' : 0.004422260880875347
                |   'ek' : 0.0009998861918155658
                |   'gn' : 0.00024387468093062579
                |   'cc' : 0.00029264961711675095
            p Now that we have our character frequencies, or character pair frequencies, we can go about testing various outputs against some encrypted strings. Of course, such tests work poorly against short excerpts, as character frequency works best with a larger pool of data. Download 
              a(href="txt/caesarEncrypted.txt") this file
              |  and read it's contents as the argument to your decryption algorithm for the caesar cypher.
            p To go about the actual decryption, you will need to write a function that opens the the text file, decrypts the file using each of the 23 possible keys, selects the iterations which most closely reflect your results from the character frequencies of Alice in Wonderland, and then returns the best 2 or 3 matches. 
    script.

      $('pre').click(function(e) {
      console.log('clicked')
      $(e.target).children().css('visibility','visible')
      $(e.target).prev().remove()
      })
